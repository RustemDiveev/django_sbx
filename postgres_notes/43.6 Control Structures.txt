Структуры управления - одни из самых важных частей PL/pgSQL. Можно гибко и мощно манипулировать данными.

----- Возврат данных из функции -----

Есть две доступные команды, позволяющие возвращать данные из функции: RETURN и RETURN NEXT.

	---------- RETURN ----------
	RETURN expression;
	
	RETURN с выражением останавливает выполнение функции и возвращает значение expression тому, кто вызвал. Такая форма используется для функций, не возвращающих множество.
	
	Если функция возвращает скалярный тип, то результат выражения будет автоматически преобразован в тип возвращаемого значения. Но, чтобы вернуть сложное (строковое) значение, необходимо написать выражение, предоставляющее в точности множество запрашиваемых колонок. Это может потребовать явного преобразования. 
	
	Если функция была объявлена без выходных параметров, то нужно написать RETURN без выражения. Текущие значения выходных параметров будут возвращены. 
	
	Если функция объявлена как возвращающая void, то выражение RETURN может использоваться для того, чтобы выйти из функции пораньше, но у RETURN не надо писать выражение. 
	
	Возвращаемое значение функции нельзя оставлять неопределенным. Если выполнение достигает конца самого высокоуровневого блока, и RETURN еще не встречался, возникнет ошибка выполнения. Это ограничение не применяется к функциям с выходными параметрами и функциям, возвращающим void. В таких случаях RETURN автоматически выполняется как только заканчивается выполнение самого внешнего блока.
	
	Примеры:
		-- скалярный тип 
		RETURN 1 + 2;
		RETURN scalar_var;
		
		-- сложный тип 
		RETURN composite_type_var;
		RETURN (1, 2, 'three'::text); -- необходимо преобразовывать колонки к правильным типам
		
	---------- RETURN NEXT и RETURN QUERY ----------	
	
	RETURN NEXT expression;
	RETURN QUERY query;
	RETURN QUERY EXECUTE command-string [ USING expression [, ... ] ];
	
	Когда функция PL/pgSQL объявлена как возвращающая SETOF sometype то выполнение происходит немного по другому. В таком случае, отдельные элементы, которые необходимо вернуть указываются через последовательность из команд RETURN NEXT или RETURN QUERY, а затем указывается итоговый RETURN без выражения, чтобы показать, что функция закончила выполнение. 
	
	RETURN NEXT может использоваться как со скалярными, так и со сложными типами данных; при использовании сложного типа - будет возвращена целая таблица результатов. 

	RETURN QUERY дописывает результаты выполнения запроса к результирующему множеству функции. 
	
	RETURN NEXT и RETURN QUERY можно свободно комбинировать в одной функции, возвращающей множество, в таком случае их результаты будут сконкатенированы. 
	
	RETURN NEXT и RETURN QUERY в действительности не возвращают значение из функции - они просто добавляют ноль или более строк к результирующему множеству функции. Выполнение затем переходит к следующему выражению в функции. Как только успешно выполняется результат команд RETURN NEXT и RETURN QUERY - наращивается результирующий набор. Финальный RETURN без аргумента - выполняет выход из функции (или можно без него).
	
	RETURN QUERY имеет вариант RETURN QUERY EXECUTE позволяющий указать запрос который будет выполняться динамически. Выражения параметров могут вставляться в вычисляемый запрос через USING, как и с обычным EXECUTE. 
	
	Если функция была объявлена с выходными параметрами, то следует написать RETURN NEXT без выражения. При каждом выполнении, текущие значения переменных выходных параметров будут сохранены для возможного последнего возврата строки с результатами. При этом необходимо объявить функцию как возвращающую множество выходных параметров или возвращающую SETOF sometype когда есть только один выходной параметр с типом sometype, для того чтобы создать функцию, возвращающую множество с выходными параметрами. 
	
	Пример функции, использующей RETURN NEXT: 
	
	CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
	
	INSERT INTO foo VALUES (1, 2, 'three');
	INSERT INTO foo VALUES (4, 5, 'six');
	
	CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS 
	$BODY$
	DECLARE 
		r foo%rowtype;
	BEGIN 
		FOR r IN
			SELECT * FROM foo WHERE fooid > 0
		LOOP
			-- что-то сделать 
			RETURN NEXT r;
		END LOOP;
		RETURN;
	END;
	$BODY$
	LANGUAGE plpgsql;
	
	SELECT * FROM get_all_foo();
	
	Пример функции, возвращающей RETURN QUERY 
	CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS 
	$BODY$
	BEGIN 
		RETURN QUERY 	SELECT flightid 
						FROM flight 
						WHERE flightdate >= $1 
						AND flightdate < ($1 + 1);
						
		-- Так как выполнение еще не закончилось, можно проверить, были ли возвращены строки 
		-- и выбросить исключение - если нет 
		
		IF NOT FOUND THEN 
			RAISE EXCEPTION 'No flight at %.', $1;
		END IF;
		
		RETURN;
	END;
	$BODY$
	LANGUAGE plpgsql;
	
	-- Возвращает доступные полеты или выбрасывает исключение, если таких полетов нет 
	SELECT * FROM get_available_flightid(CURRENT_DATE);
	
	Примечание: текущая реализация RETURN NEXT и RETURN QUERY хранит результирующий набор перед тем как возвращать его из функции. Это означает, что если PL/pgSQL функция возвращает очень большое множество данных, то производительность может пострадать: данные будут записываться на диск, чтобы не переполнять память, но функция сама по себе не вернет результат пока не будет сгенерировано итоговое множество. Будущая версия PL/pgSQL возможно позволит пользователям определять функции возвращающие множество и не имеющее этого ограничения. В настоящее время, момент, начиная с которого данные начинают записываться на диск контролируется конфигурационной переменной work_mem. Администраторы у которых есть достаточно памяти чтобы хранить большие наборы данных в памяти, могут задуматься над увеличением значения параметра.
	
----- Возврат значения из процедуры ----- 

У процедуры нет возвращаемого значения. Процедура может заканчиваться без конструкции RETURN. Если хочется выйти из процедуры раньше, можно написать RETURN без выражения. 

Если у процедуры есть выходные параметры, то итоговые значения переменных выходных параметров будут возвращены. 

----- Вызов процедуры -----
PL/pgSQL функция, процедура или блок с DO - может вызывать процедуру используя CALL. Обработка выходных параметров отличается от того способа, что CALL работает в обычном SQL. Каждый OUT и INOUT параметр процедуры должен соотноситься с CALL, и вне зависимости от того, что возвращает процедура должно быть назначено той же переменной, после которой процедура возвращает результат. Пример: 

	CREATE PROCEDURE triple(INOUT x int)
	LANGUAGE plpgsql 
	AS $$ 
	BEGIN 
		x := x * 3;
	END;
	$$;
	
	DO $$ 
	DECLARE myvar int := 5;
	BEGIN 
		CALL triple(myvar);
		RAISE NOTICE 'myvar = %', myvar; -- 15 
	END;
	$$;
	
Переменная соответствующая выходному параметру может быть простой переменной или полем переменной сложного типа. Сейчас, она не может быть элементом массива. 

----- Условные операторы ----- 

Инструкции IF и CASE позволяют выполнять альтернативные команды, основанные на определенных условиях. В PL/pgSQL есть три формы IF: 

	IF ... THEN ... END IF 
	IF ... THEN ... ELSE ... END IF 
	IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF 
	
и две формы CASE: 
	
	CASE ... WHEN ... THEN ... ELSE ... END CASE 
	CASE WHEN ... THEN ... ELSE ... END CASE 
	
Здесь я не пишу дальше, так как это работает один в один как в PLSQL. 
	
Единственное, что интересно в CASE - если не найдено условие будь то форма SEARCH CASE или обычный CASE и не указан ELSE - то будет выброшено исключение CASE_NOT_FOUND.

----- Простые циклы ----- 
C выражениями LOOP, EXIT, CONTINUE, WHILE, FOR и FOREACH можно управлять функцией, чтобы повторять выполнение серий команд. 

	---------- LOOP ----------
	
	[ <<label>> ]
	LOOP 
		statements 
	END LOOP [ label ];
	
	LOOP определяет безусловный цикл, повторяющийся бесконечно пока его не прекратит выражение EXIT или RETURN. Необязательный label может использоваться EXIT и CONTINUE внутри вложенных циклов, чтобы указать к каклму циклу эти выражения относятся. 
	
	---------- EXIT ----------
	
	EXIT [ label ] [ WHEN boolean-expression ];
	
	Если label не задан, то самый внутренний цикл прекращается и выражение, следующее за END LOOP выполняется следующим. Если label задан, то он должен описывать текущий блок или какой-то внешний блок или цикл. Тогда именованный цикл или блок прекращает свое выполнение, и тогда контроль передается выражение после END цикла/блока. 
	
	Если указан WHEN, то выход из цикла выполняется когда boolean-expression true. Иначе, выполнение передается выражению после EXIT. 
	
	EXIT можно использовать со всеми типами циклов.
	
	Когда используется с блоком BEGIN, EXIT передает контроль в следующее выражение после конца блока. label должен использоваться с этой же целью, непомеченный EXIT никогда не считается совпадением с блоком BEGIN. Примеры: 
	
	LOOP
		-- какие-то вычисления 
		IF count > 0 THEN 
			EXIT; -- выход из цикла 
		END IF;
	END LOOP;
	
	LOOP 
		-- какие-то вычисления  
		EXIT WHEN count > 0; -- то же что и предыдущий пример 
	END LOOP;
	
	<<ablock>>
	BEGIN 
		-- какие-то вычисления 
		IF stocks > 100000 THEN 
			EXIT ablock; -- выход из блока BEGIN 
		END IF;
		-- Вычисления будут пропущены, когда stocks > 100000 
	END;
	
	---------- CONTINUE ----------
	
	CONTINUE [ label ] [ WHEN boolean-expression ];
	
	Если label задан, то начинается следующая итерация самого внутреннего цикла. Все оставшиеся выражения в теле цикла пропускаются и контроль возвращается к выражению управления циклом (если такое есть) чтобы определить нужна ли еще одна итерация цикла. Если label есть, то указывается лейбл цикла выполнение которого будет продолжено. 
	
	Если указано WHEN, то следующая итерация цикла начинается только тогда если boolean-expression true. В другом случае, контроль передается к выражению после CONTINUE;
	
	CONTINUE можно использовать со всеми типами циклов. 
	
	Примеры: 
	LOOP 
		-- some computations 
		EXIT WHEN count > 100;
		CONTINUE WHEN count < 50;
		-- Вычисления для count в [50 .. 100]
	END LOOP;
	
	---------- WHILE ----------
	[ <<label>> ]
	WHILE boolean-expression LOOP
		statements 
	END LOOP [ label ];
	
	WHILE позволяет последовательность выражений так долго, пока boolean-expression true. Выражение проверяется каждый раз перед каждым входом в тело цикла.
	
	Примеры: 
	WHILE amount_owed > 0 AND gift_certificate_balance > 0 LOOP 
		-- 
	END LOOP;
	
	WHILE NOT done LOOP 
		--
	END LOOP;
	
	---------- FOR (вариант с целым числом) ----------
	[ <<label>> ]
	FOR name IN [ REVERSE ] expression .. expression [ BY expression ]
	LOOP
		statements 
	END LOOP [ label ];
	
	Такая форма FOR создает цикл итерирующийся по диапазону целочисленных значений. Переменная name автоматически определяется с типом integer и существует только внутри цикла (любое существующее объявление имени переменной игнорируется внутри цикла). Два выражения с нижней и верхней границей вычисляются один раз при входе в цикл. Если BY не указано, то шаг итерации - 1, иначе - это значение указанное в BY - которое вычисляется один раз при входе в цикл. Если указан REVERSE, то значение шага вычитается на каждой итерации цикла. 
	
	Примеры: 
	
	FOR i IN 1..10 LOOP
		--i 1,2,...,10
	END LOOP;
	
	FOR i IN REVERSE 10..1 BY 2 LOOP 
		--i 10,8,6,4,2 
	END LOOP;
	
	Если нижняя граница больше чем верхняя (в случае с REVERSED, то наоборот), то тело цикла вообще не выполняется. Ошибка не выбрасывается. 
	
	Если label есть у циукла FOR, тогда к переменной цикла можно обращаться через label. 
	
----- Итерация по результатам запроса -----
Используя другой тип цикла FOR, можно итерироваться по результатам запроса и управлять этими данными. Синтаксис: 

[ <<label>> ]
FOR target IN query LOOP 
	statements 
END LOOP [ label ];

target - переменная record, или строковая, или разделенный запятой список скалярных переменных. target успешно назначается каждой строки, получающейся из query и тело цикла выполняется для каждой строки. Пример: 

CREATE FUNCTION refresh_mviews() RETURNS integer AS $$ 
DECLARE 
	mviews RECORD;
BEGIN 
	RAISE NOTICE 'Refreshing all materialized views...';
	
	FOR mviews IN 
		SELECT 	n.nspname AS mv_schema,
				c.relname AS mv_name,
				pg_catalog.pg_get_userbyid(c.relowner) AS owner
		FROM 	pg_catalog.pg_class c 
	LEFT JOIN	pg_catalog.pg_namespace n ON (n.oid = c.relnamespace) 
		WHERE 	c.relkind = 'm'
	ORDER BY 	1 
	
	LOOP 
		
		-- В mviews есть одна запись с информацией о материализованном представлении 
		RAISE NOTICE 	'Refreshing materialized view %.% (owner: %)...',
						quote_ident(mviews.mv_schema),
						quote_ident(mviews.mv_name),
						quote_ident(mviews.owner)
		EXECUTE format('REFRESH MATERIALIZED VIEW %I.%I', mviews.mv_schema, mviews.mv_name);
	
	END LOOP;
	
	RAISE NOTICE 'Done refreshing materialized views.';
	RETURN 1;
	
END;
$$ LANGUAGE plpgsql;

Если цикл завершается EXIT, то последнее присвоенное строковое значение остается доступным после выхода из цикла. 

query, использующаяся в таком типе выражения FOR может любой SQL командой, возвращающей строки: SELECT самое частое, но можно использовать INSERT, UPDATE или DELETE с конструкцией RETURNING. Некоторые команды утилиты как EXPLAIN тоже будут работать. 

PL/pgSQL переменные заменяются параметрами запроса и план запроса кэшируется для возможного переиспользования.

FOR-IN-EXECUTE другой способ итерации над строками: 

[ <<label>> ]
FOR target IN EXECUTE text_expression [ USING expression [, ...] ]
LOOP
	statements 
END LOOP [ label ];

Также как предыдущая форма, кроме того что запрос источник указан как строковое выражение, вычисляющееся и перепланируемое при каждом входе в цикл. Это позволяет выбирать между скоростью спланированного запроса или гибкостью динамического запроса - по аналогии с EXECUTE. Также по аналогии с ним, значения параметров могут вставляться в динамическую команду через USING. 

Другой способ указать запрос по результатам которого необходимо итерироваться - объявить как курсор. 

----- Цикл по массивам ----- 
Цикл FOREACH похож на цикл FOR, но вместо итерации по строкам, возвращаемым через SQL запрос - итерация происходит по значениям массива. В общем случае, FOREACH предназначается для итерирования по компонентам сложнозначного выражения; варианты по итерированию по сложным структуром кроме массивов - могут быть добавлены в будущем). Выражение FOREACH чтобы итерироваться по массиву: 

[ <<label>> ]
FOREACH target [ SLICE number ] IN ARRAY expression LOOP
	statements 
END LOOP [ label ];

Без SLICE или когда SLICE = 0, цикл итерируется по индивидуальным элементам массива, которые получаются при вычислении expression. Переменная target назначается каждому значению элемента в последовательности и тело цикла выполняется для каждого элемента. Нижк пример цикла по элементам целочисленного массива: 

CREATE FUNCTION sum(int[]) RETURNS int8 AS $$ 
DECLARE 
	s int8 := 0;
	x int;
BEGIN 
	FOREACH x IN ARRAY $1 
	LOOP 
		s := s + x;
	END LOOP;
	RETURN s;
END;
$$ LANGUAGE plpgsql;

Элементы посещаются в порядке хранения, вне зависимости от количества измерений массива. Так как target обычно обычная переменная, она может быть списком переменных при итерировании цикла сложных значений (records). В таком случае, для каждого элемента массива, значения в переменную присваиваются из колонок сложного значения. 

С положительным значением SLICE, FOREACH итерируется через срезы массива, а не обычных элементов. Значение SLICE должно быть целочисленной константой не больше количества элементов в массиве. Переменная target должна быть массивом, и должна успешно получать срезы значения массива, где каждый срез - количество измерений указанных в SLICE. Ниже приведен пример измерений: 

CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$ 
DECLARE 
	x int[];
BEGIN 
	FOREACH x SLICE 1 IN ARRAY $1 
	LOOP 
		RAISE NOTICE 'row = %', x;
	END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]);

NOTICE: row = {1,2,3}
NOTICE: row = {4,5,6}
NOTICE: row = {7,8,9}
NOTICE: row = {10,11,12}

----- Отлов ошибок -----
По умолчанию, любая ошибка возникающая в PL/pgSQL функции отменяет выполнение функции и окружающей её транзакции. Можно ловить ошибки и восстанавливаться из них используя блок BEGIN с EXCEPTION. Такой синтаксис - расширение нормального синтаксиса для блока BEGIN.

[ <<label>> ]
[ DECLARE 
	declarations ] 
BEGIN
	statements 
EXCEPTION 
	WHEN condition [ OR condition ... ] THEN 
		handler_statements
	[WHEN condition [ OR condition ... ] THEN 
		handler_statements 
	... ]
END;

Если ошибка не возникает, то такой блок просто выполняет statements, а затем контроль передается к следующему выражению после END. Но если ошибка возникает внутри statements, дальнейшая обраьотка statements не выполняется и управление переается к списку EXCEPTION. В списке ищется первое условие к


 

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	