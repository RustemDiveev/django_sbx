Postgres дает набор ролей, которые дают доступ к часто используемым возможностям и информации. Администраторы (включая роли, у которых есть привилегия CREATEROLE) могут назначать данные привилегии пользователям и/или другим ролям в среде, предоставляя пользователям доступ к определенным возможностям и информации. 

Преднастроенные роли приведены снизу. Перечень привилегий может меняться от релиза к релизу. 

	pg_read_all_data - чтение всех данных (таблицы, представления, последовательности), то же самое, что и иметь привилегию SELECT на этих объектах, и привилегию USAGE на всех схемах, даже если не иметь её явно. У этой роли нет атрибута BYPASSRLS. Если используется RLS, то администратор может захотеть выдать BYPASSRLS на те роли, которым выдана эта роль.
	
	pg_write_all_data - запись всех данных (таблицы, представления, последовательности). То же самое, что и иметь привилегии INSERT, UPDATE и DELETE на эти объекты, и привилегию USAGE на всех схемах, даже если её нет явно. У этой роли, по аналогии с верхней, тоже не выставлен атрибут BYPASSRLS. 
	
	pg_read_all_settings - чтение всех переменных конфигурации, в том числе и тех, что обычно доступны только суперпользователям. 
	
	pg_read_all_stats - чтение всех представлений pg_stat_* и использование различных расширений, связанных со статистикой, даже тех, которые обычно доступны только суперпользователям. 
	
	pg_stat_scan_tables - выполнение функций мониторинга, которые могут устанавливать ACCESS SHARE блокировки на таблицы, потенциально - на длительное время 
	
	pg_monitor - читает / выполняет различные представления и функции мониторинга. Эта ролья является членом pg_read_all_settings, pg_read_all_stats, pg_stat_scan_tables. 
	
	pg_database_owner - ничего. Эта роль неявно является членом текущего владельца БД. 
	
	pg_signal_backend - позволяет отправлять сигнал бэкенду для отмены запроса или уничтожении его сессии. 
	
	pg_read_server_files - позволяет читать файлы из любого места, где БД имеет доступ с функцией COPY и другими функциями файлового доступа 
	
	pg_write_server_files - то же самое, что и верхняя роль, только на запись 
	
	pg_execute_server_program - позволяет выполнять программы на сервере БД как пользователь под которым выполняется БД с функцией COPY и другими функциями, позволяющими выполнить программу на стороне сервера 
	
Роли pg_monitor, pg_read_all_settings, pg_read_all_stats, pg_stat_scan_tables предназначены для того, чтобы позволяить администраторам с легкостью сконфигурировать роль с целью мониторинга сервера БД. Они раздают набор общих привилегий, позволяющих роли читать различные полезные настройки конфигурации, статистики и другую системную информацию, обычно доступную только суперпользователям. 

pg_database_owner - всегда имеет неявно одного, зависящего от ситуации, члена, который является владельцем текущей БД. Эта роль изначально не передает никаких прав. Как любая другая роль, она может владеть объектами и получать привилегии доступа. Следовательно, как только у pg_database_owner есть права внутри шаблонной БД, каждый владелец БД инициированной из этого шаблона, будет наследовать данные права. pg_database_owner не может быть членом какой-либо роли, и не может иметь неявных членов. 

pg_signal_backend - предназначена для того, чтобы позволить администраторам активировать доверенные роли (но не суперпользователей), чтобы посылать сигналы другим бэкендам. В настоящий момент данная роль включает рассылку сигналов, говорящих об отмене выполнения запроса другого бэкенда или уничтожение его сессии. Пользователь, получивший эту роль не может посылать сигналы бэкенду, которым владеет суперпользователь.

pg_read_server_files, pg_write_server_files и pg_execute_server_program - предназначены для того, чтобы позволить администраторам иметь доверенные роли (не суперпользователей), которые могут обращзаться к файлам и выполнять программы на сервере БД как пользователь под которым работает БД. Так как эти роли имеют доступ к любому файлу на серверной файловой системе, они обходят все проверки на уровне БД при прямом обращении к файлу, и могут использоваться для получения доступа уровня суперпользователя, но такие роли необходимо выдавать с осторожностью.

Администраторы могут выдавать эти роли при помощи команды GRANT, например: 
GRANT pg_signal_backend TO admin_user;
