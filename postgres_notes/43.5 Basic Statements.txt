В этом и последующих разделах описываются все типы выражений, которые явно понимаются PL/pgSQL. Все что опущено, подразумевается, что это SQL команда и может быть отправлена в движок БЛ на выполнение. 

----- Присваивание -----

Присваивание значения переменной записывается так: 

variable { := | = } expression;

Как объяснялось ранее, выражение в этом утверждении вычисляется через SQL SELECT, который отправляется в движок БД. Выражение должно уступать одно значение (строчное значение, если переменная строчная или record). Переменная назначения может быть простой переменной (возможно с именем блока), полем или строкой или record, или элементом или срезом массива. Можно использовать (=) вместо (:=).

Если результирующий тип данных не совпадает с типом данных переменной, то значение будет принудительно изменено, как будто при явном преобразовании типа данных. Если не известен способ преобразования для пары типов данных, интерпретатор постарается преобразовается результирующее значение в текст, путем применения к результирующему типу выходную функцию, за которой следует вызов входной функции. Это может привести к ошибкам выполнения, генерируемой входной функцией, если строковая форма результирующего значения не принимается входной функцией. 

Примеры:
	tax := subtotal * 0.06;
	my_record.user_id := 20;
	my_array[j] := 20;
	my_array[1:3] := array[1, 2, 3];
	complex_array[n].realpart = 12.3;
	
----- Выполнение SQL команд -----

В общем случае, любая SQL команда, не возвращающая строки может выполняться внутри PL/pgSQL функции путем записи командв. Например, можно создать и заполнить таблицу:

CREATE TABLE mytable (id int primary key, data text);
INSERT INTO mytable VALUES (1, 'one'), (2, 'two');

Если команда возвращает строки (например, SELECT или INSERT/UPDATE/DELETE с RETURNING), то есть два возможных пути. Когда команда возвращает только одну строку, или когда важна только первая строка, можно написать команду как обычно, но добавить INTO чтобы захватить выходные данные. Чтобы обработать все выходные строки, следует написать команду как источник данных для цикла FOR.

Обычно выполнять статически определенные SQL команды не эффективно. Как правило, необходимы команды, использующие различающиеся значения, или различающиеся более фундаментально = например, имена таблиц. Есть два способа решения в зависимости от ситуации:

Значения переменных PL/pgSQL могут быть автоматически вставлены в оптимизируемые SQL команды: SELECT, INSERT, UPDATE, DELETE и определенные команды-утилиты, которые можно встроить в эти команды, например: EXPLAIN или CREATE TABLE ... AS SELECT. В таких командах, любое имя переменной PL/pgSQL появляющееся в тексте команды заменяется на параметр запроса, а затем, текущее значение переменной определяется как значение параметра во время выполнения. То же самое, что и процессинг описанный ранее для выражений. 

При выполнении оптимизируемой SQL команды таким способом, PL/pgSQL может кэшировать и переиспользовать план выполнения для команды. 

Не оптимизируемые SQL команды (также называются командами утилитами) не способны принимать параметры запроса. Поэтому автоматическая подмена переменных PL/pgSQL не работает в таких командах. Чтобы включить текст не константу в команду утилиту, выполняемую из PL/pgSQL необходимо построить команду утилиту как строку, а затем выполнить EXECUTE. 

EXECUTE должна также использоваться, если необходимо изменить команду немного другим путем, чем просто указывать значение данных, например при изменении имени таблицы. 

Иногда требуется вычислять выражение или SELECT запрос, но отбрасывать результат, например при вызове функции, которая что-то делает на стороне, но имеет бесполезное возвращаемое значение. Чтобы выполнить это в PL/pgSQL необходимо использовать инструкцию PERFORM:

	PERFORM query;
	
Это выполняет query и отбрасывает результат. Следует записать query также как пишется SQL SELECT, но заменить SELECT на PERFORM. Для запросов WITH, необходимо использовать PERFORM и поместить запрос в скобки (в таком случае запрос может вернуть только одну строку). 

PL/pgSQL переменные будут подменены в запросе, также как и описано выше, и план тоже будет закэширован. Также, специальная переменная FOUND примет значение true если запрос вернул хотя бы одну строку, или false - если нет строк. 

Можно ожидать, что написание SELECT напрямую позволит отбросить результат, но в настоящее время единственный допустимый путь - выполнить PERFORM. SQL-команда которая может вернуть строки, например SELECT будет отвергута с ошибкой, если отсутствует конструкция INTO. 

Пример: 
	PERFORM create_mv('cs_session_page_requests_mv', my_query);
	
----- Выполнение команды с результатом в виде одной строки -----

Результат SQL-команды уступающий одну строку (может быть несколько колонок) может быть присвоен переменной record, строчной переменной или списку скалярных переменных. Это можно сделать при помощи SQL команды и INTO, например: 

SELECT select_expressions INTO [STRICT] target FROM ...;
INSERT ... RETURNING expressions INTO [STRICT] target;
UPDATE ... RETURNING expressions INTO [STRICT] target;
DELETE ... RETURNING expressions INTO [STRICT] target;

где target переменная record, строчная переменная, или разделенный через запятую список обычных переменных и record/row полей. PL/pgSQL переменные будет заменены в команде (все кроме INTO) и план будет кэширован. Такое работает с SELECT, INSERT/UPDATE/DELETE с RETURNING и определенными командами-утилитами возвращающие наборы строк, такие как EXPLAIN. SQL команда такая же в обычном SQL, за исключением INTO. 

Следует отметить, что интерпретация SELECT с INTO немного отличается от команды Postgres SELECT INTO, где INTO - новая созданная таблица. Если необходимо создать таблицу из результата, то использовать CREATE TABLE ... AS SELECT.

Если переменная строки или переменная списка используется как приемник - то результирующие колонки результата должны в точности совпадать со структурой приемника по количеству и типу данных, или возникнет ошибка выполнения. Когда перемененая record приемник - она автоматически настраивает сама себя, чтобы соответствовать колонкам результата. 

INTO может быть практически везде в SQL команде. По умолчанию его пишут или после, или до списка select_expressions в команде SELECT, или в конце команды для других типов команды. Рекомендуется следовать этой конвенции.

Если STRICT не указан в INTO, тогда target - первая строка, возвращаемая командой, или nulls - если команда не вернула строк. Первая строка может быть недетерминирована, если нет ORDER BY. Оставшиеся строки в результате отбрасываются. Можно посмотреть переменную FOUND, чтобы определить была ли возвращена строка: 

SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
	RAISE EXCEPTION 'employee % not found', myname;
END IF;

Если STRICT указано, то команда должна возвращать ровно одну строку, или будет выброшена ошибка выполнения: NO_DATA_FOUND или TOO_MANY_ROWS. Можно использовать блок исключений для ловли ошибок: 
	
	BEGIN
		SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
		EXCEPTION 
			WHEN NO_DATA_FOUND THEN 
				RAISE EXCEPTION 'employee % not found', myname;
			WHEN TOO_MANY_ROWS THEN 
				RAISE EXCEPTION 'employee % not unique', myname;
	END;
	
	Успешное выполнение команды со STRICT всегда делает FOUND true.
	
	Для INSERT/UPDATE/DELETE с RETURNING PL/pgSQL выбросит ошибку если есть более чем одна возвращаемая строка, даже когда STRICT не указан. Это сделано потому что нет возможности указать ORDER BY по которой можно было бы определить какая строка должна быть возвращена.
	
	Если print_strict_params включена для функции, то тогда ошибка выбрасывается из-за того, что требования STRICT не выполняются, часть DETAIL сообщения об ошибке будет включать параметры, переданные в команду. Можно изменить print_strict_params для всех функций путем настройки (или установки) plpgsql.print_strict_params, это повлияет только на последующие компилирования функции. Можно также включить это для отдельной функции через опцию компилятора, например:
	
	CREATE FUNCTION get_userid(username text) RETURNS int AS $$ 
	#print_strict_params on 
	DECLARE 
		userid int;
	BEGIN 
		SELECT users.userid INTO STRICT userid 
		FROM users WHERE users.username = get_userid.username;
		RETURN userid;
	END;
	$$ LANGUAGE plpgsql;
	
	При ошибке например будет сгенерировано следующее сообщение:
	ERROR: query returned no rows 
	DETAIL: parameters: $1 = 'nosuchuser'
	CONTEXT: PL/pgSQL function get_userid(text) line 6 at SQL statement 
	
----- Динамическое выполнение команд ----- 

Зачастую пиходится генерировать динамические команды внутри функций, те команды которые будут использовать разные таблицы или разные типы данных при каждом выполнении. Кэширование плана не будет выполняться в таких случаях. Для того, чтобы решить проблему, есть инструкция EXECUTE:

	EXECUTE command-string [ INTO [STRICT] target ] [ USING expression [, ... ] ];

	command-string - выражение, удерживающее строку типа данных text, содержащая исполняемую команду. target - может быть переменной record, или переменной строки, или разделенный через запятую список из переменных, в которых будут храниться результаты команды.
	
	USING - дает возможность указать значения, которые будут использоваться в команде.
	
	Подстановка переменных не выполняется у вычисленной command-string. Все требуемые значения должны быть вставлены в команду как только она сконструирована, или можно использовать параметры так, как описано ниже. 
	
	Также, план не кэшируется для команд, выполняющихся через EXECUTE. Вместо этого для команды всегда встроится план при каждои запуске выражения. При этом строка с командой может быть создана динамически внутри функции, чтобы выполнять действия над различными таблицами и колонками.
	
	INTO указывает в какие переменные необходимо помещать результаты SQL команды. Если в INTO строчная переменная или переменная списка, то она должна в точности совпадать со структурой результатов выполняемой команды, record сконфигурирует свою структуру автоматически. Если возвращается несколько строк, то только первая будет присвоена в переменные в INTO. Если вернулось 0 строк, то переменным присваивается null. Если INTO не указан, то результаты команды отбрасываются.
	
	Если указан STRICT - то выбрасывается ошибка, если вернулась не 1 строка. 
	
	Строка с командой может использовать параметризованные значения, на которые можно ссылаться в команде через $1, $2 итд. Эти символы соответствуют значениям, указанным в USING. Метод более предпочтителен для вставки значений в строковой литерал команды в качестве текста, оно избегает конвертации значений в текст и обратно, и более устойчивое к SQL-инъекциям, так как нет необходимоти экранирования или заключения значений в кавычки. Пример: 
	
	EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted <= $2' 
	INTO c 
	USING checked_user, checked_date;
	
	Следует обратить внимание, что символы параметров могут использоваться только для значений данных, если необходимо динамически определить таблицу или колонку, их нужно вставлять вручную в команду. Например, так:
	
	EXECUTE 'SELECT count(*) FROM ' 
		|| quote_ident(tabname) 
		|| ' WHERE inserted_by = $1 and inserted <= $2'
	INTO c 
	USING checked_user, checked_date;
	
	Более правильный подход - использовать format() %I, чтобы вставить таблицу или колонку с автоматическим экранированием:
	
	EXECUTE format('SELECT count(*) FROM %I '
		'WHERE inserted_by = $1 and inserted <= $2', tabname)
	INTO c 
	USING checked_user, checked_date;
	
	Есть SQL-правило, что строковые литералы разделенные символом новой строки неявно конкатенируются. 
	
	Другое ограничение на символах параметров - они только работают в оптимизируемых SQL-командах SELECT, INSERT, UPDATE, DELETE и в других определенных командах, содержащих один из этих команд. В других командах-утилитах нужно вставлять значения как текст, даже если это всего лишь значения. 
	
	EXECUTE с простой константной командной строкой и несколькими параметрами в USING - функционалдьно эквивалентно записи команды напрямую в PL/pgSQL и позволяет подмене PL/pgSQL переменных происходить автоматически. Важная разница в том, что EXECUTE будет переплаировать команду при каждом выполнении, генерирую свой план для текущих значений параметров, тогда как PL/pgSQL может создать универсальный план и кэшировать его для переиспользования. В ситуациях где лучший план выполнения сильно зависит от самих значений параметров может быть полезно использовать EXECUTE для того, чтобы универсальный план не выбирался. 
	
	SELECT INTO на текущий момент не поддерживается внутри EXECUTE, вместо этого можно выполнить SELECT и указать INTO как часть EXECUTE. 
	
	EXECUTE в PL/pgSQL отличается от EXECUTE в SQL. 
	
	При работе с динамичскими командами часто приходится обрабатывать случай экранирования одинарных кавычек. Рекомендуемый способ - долларовые кавычки. 
	
	Динамические значения требует аккуратной работы, так как они могут содержать кавычки. Пример обработки при помощи format():
	
	EXECUTE format('UPDATE tbl SET %I = $1 '
		'WHERE key = $2', colname) USING newvalue, keyvalue;
	
	Также можно вызывать функции, экранирующие кавычки, напрямую:
	
	EXECUTE 'UPDATE tbl SET '
		|| quote_ident(colname) 
		|| ' = '
		|| quote_literal(newvalue)
		|| ' WHERE key = ' 
		|| quote_literal(keyvalue);
		
	В примере используются функции quote_ident и quote_literal. Для безопасности, выражения, содержащие названия колонок или таблиц должны быть переданы через quote_ident перед вставкой в динамический запрос. Выражения, содержащие значения должны быть строковыми литералами в команде, необходимо пропустить через quote_literal. Эти функции выполняют определенные шаги для того, чтобы вернуть текст в двойных и одинарных кавычках соответственно, экранируя все встроенные специальные символы. 
	
	Так как quote_literal помечен как STRICT, то функция всегда будет возвращать null, если в нее был передан null. В примере выше, если бы newvalue или keyvalue были бы null, то вся строка стала бы null и привела к ошибке при вызове EXECUTE. Можно избежать этой проблемы используя функцию quote_nullable, работающая также как и quote_literal за исключением того, что при вызове с аргументом, равным NULL - вернет строковой NULL. Например: 
	
	EXECUTE 'UPDATE tbl SET '
		|| quote_ident(colname) 
		|| ' = '
		|| quote_nullable(newvalue)
		|| ' WHERE key = ' 
		|| quote_nullable(keyvalue);
	
	Если идет работа со значениями, которые потенциально могут быть null, необходимо обычно использовать quote_nullable вместо quote_literal. 
	
	Необходимо удостовериться, что null значения в запросе не выдают нежелаемые результаты. Например, в WHERE: 
	
	'WHERE key = ' || quote_nullable(keyvalue) 
	
	никогда не будет валидной команды, если keyvalue null, так как результат оператора равенства с null - всегда null. Если необходимо сделать так, чтобы null работало как обычное значение необходимо переписать на:
	
	'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)
	
	(В настоящее время IS NOT DISTINCT FROM обрабатывается менее производительно чем =, поэтому не стоит все время его использовать).
	
	Долларовые кавычки следует использовать только для обертки над фиксированным текстом. Пример того, как не надо делать:
	
	EXECUTE 'UPDATE tbl SET '
		|| quote_ident(colname) 
		|| ' = $$'
		|| newvalue 
		|| '$$ WHERE key = ' 
		|| quote_literal(keyvalue);
		
	Если newvalue будет содержать $$, то запрос сломается. То же самое применимо к любому другому разделителю при его оборачивании в долларовые кавычки. Таким образом, для того чтобы безопасно заключать текст в кавычки, который неизвестен на текущий момент, необходимо использовать quote_literal, quote_nullable или quote_ident где возможно. 
	
	Динамические SQL выражения моэно спокойно сконструировать при поиощи функции format. Например, 
	
	EXECUTE format('UPDATE tbl SET %I = %L '
		'WHERE key = %L', colname, newvalue, keyvalue);
		
	%I - эквивалентно quote_ident 
	%L - эквивалентно quote_nullable 
	
	Функция format может использоваться в сочетании с USING:
	EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
		USING newvalue, keyvalue;
		
	Такая форма лучше так как переменные обрабатываются в нативном формате типов данных, нежели безусловно преобразовывая их в текст и заключая в кавычки через %L. Это еще и эффективнее. 
	
----- Получение статуса результата выполнения ----- 

Есть несколько способов определить эффект от выполнения команды.

Первый способ - использовать команду GET DIAGNOSTICS, которая имеет форму:
GET [ CURRENT ] DIAGNOSTICS variable { = | := } item [ , ... ];

Эта команда позволяет получить индикаторы статуса системы: CURRENT - пропускамое слово. Каждый элемент - ключевое слово, идентифицирующее значение статуса, которое будет назначено указанной variable (должна быть правильного типа данных).

Пример выполнения:
GET DIAGNOSTICS integer_var = ROW_COUNT;

Доступные элементы для диагностики:
ROW_COUNT - bigint - количество строк, обработанных самой последней SQL-командой 
PG_CONTEXT - text - строки текста, описывающие текущий стек вызова 

Второй способ - определить эффект от выполнения команды можно при помощи специальной переменной FOUND, имеющей тип boolean. FOUND изначально имеет значение FALSE внутри каждого вызова функции PL/pgSQL. Есть следующие правила того, каким образом она принимает значение в зависимости от типов выражений:

	- SELECT INTO устанавливает FOUND в true, если строка присвоена, false - если ни одна строка не вернулась 
	
	- PERFORM устанавливает FOUND в true если оно возвращает (и отбрасывает) одну или более строк, false - если ни одна строка не вернулась 
	
	- UPDATE, INSERT, DELETE устанавливают FOUND в true, если затронута хотя бы 1 строка, false - если ни одной 
	
	- FETCH устанавливает FOUND в true если возвращается строка, false - если строки не вернулось 
	
	- MOVE устанавливает FOUND в true, если успешно меняет позицию курсора, иначе false 
	
	- RETURN QUERY и RETURN QUERY EXECUTE устанавливают FOUND в true, если запрос возвращает хотя бы 1 строку, иначе ни одна строка не возвращается 
	
Другие PL/pgSQL выражения не изменяют состояние FOUND. Особенно важно, что EXECUTE изменяет выходные данные GET DIAGNOSTICS, но не изменяет FOUND. 

FOUND - локальная переменная внутри каждой PL/pgSQL функции - любые изменения сделанные с ней влияют только на текущую функцию.

----- Ничего не делать ----

Иногда нужно выражение, которое ничего не делает. Например, может показывать, что одна часть if/then/else намеренно пустая. Следует использовать инструкцию NULL:

	NULL;
	
Например, следующие два фрагмента кода эквивалентны:

BEGIN 
	y := x / 0;
EXCEPTION 
	WHEN division_by_zero THEN 
		NULL; -- игнорировать ошибку 
END;

BEGIN
	y := x / 0;
EXCEPTION 
	WHEN division_by_zero THEN -- игнорировать ошибку 
END;

Что предпочтительнее - вкусовщина. 
