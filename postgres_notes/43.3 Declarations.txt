Все переменные, использующиеся в блоке должны быть объявлены в секции объявлений блока. (Единственные исключения - переменная цикла FOR, итерирующаяся по диапазону целочисленных значений, которая автоматически объявляется как целочисленная переменная; и переменная, итерирующаяся по циклу FOR для результата курсора автоматически объявляется как переменная record).

PL/pgSQL переменные могут быть любого типа данных SQL - такой как integer, varchar, char. 

Ниже примеры объявлений переменных:
	user_id integer;
	quantity numeric(5);
	url varchar;
	myrow tablename%ROWTYPE;
	myfield tablename.columnname%TYPE;
	arow RECORD;
	
Обобщенный синтаксис объявления переменной:
	name [ CONSTANT ] type [ COLLATE collation_name ] [ NOT NULL ]
		[ {DEFAULT | := | = } expression ];
		
Конструкция DEFAULT, если она задана, указывает начальное значение, назначенное переменной, когда происходит вход в блок. Если DEFAULT не заданго, то переменная инициализируется в SQL значение null. 

Опция CONSTANT предотвращает присваивание переменной после инициализации, таким образом, что данное значение останется постоянным на все время блока. 

Опция COLLATE определяет порядок сортировки для использования переменной. 

Если указано NOT NULL то присваивание переменной null-значения вызывает ошибку при запуске. 

Все переменные, объявленные как NOT NULL должны иметь не null значение по умолчанию. Можно использовать (=) вместо PLSQL-ного (:=).

Значение переменной по умолчанию вычисляется и присваивается переменной каждый раз, когда происходит вход в блок (не один раз, за вызов функции). Таким образом, присвоение now() переменной типа timestamp делает так, что переменная будет иметь время текущего вызова функции, а не время когда функция была прекомпилирована. 

Примеры: 
	quantity integer DEFAULT 32;
	url varchar := 'http://mysite.com';
	user_id CONSTANT integer := 10;
	
----- Объявление параметров функций -----

Параметры, переданные в функцию промаркированы идентификаторами $1, $2 итд. Дополнительно, можно задать псевдонимы для имен параметров вида $n для улучшения читаемости. Как псевдоним, так и числовой идентификатор можно использовать для обращения к значению параметра. 

Есть два способа создать псевдоним. Предпочитаемый способ - задать имя параметру в команде CREATE FUNCTION, например:

	CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$ 
	BEGIN 
		RETURN subtotal * 0.06;
	END;
	$$ LANGUAGE plpgsql;
	
Другой способ явно объявить псевдоним, используя синтаксис объявления 

	name ALIAS FOR $n;
	
Тот же пример в этом стиле выглядит так: 
	CREATE FUNCTION sales_tax(real) RETURNS real AS $$
	DECLARE 
		subtotal ALIAS FOR $1;
	BEGIN 
		RETURN subtotal * 0.06;
	END;
	$$ LANGUAGE plpgsql;
	
Примечания: данные два примера не являются полностью эквивалентными. В первом случае, к subtotal можно сослаться как sales_tax.subtotal, во втором случае - нет. Если бы мы присоединили label ко внутреннему блоку, к subtotal можно было бы обратиться по этому лейблу.

Больше примеров:
	CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$ 
	DECLARE 
		v_string ALIAS FOR $1;
		index ALIAS FOR $2;
	BEGIN 
		-- какие-то вычисления 
	END;
	$$ LANGUAGE plpgsql;
	
	CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
	BEGIN
		RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
	END;
	$$ LANGUAGE plpgsql;
	
	Когда функция объявлена с выходными параметрами, выходным параметрам даются имена вида $n и необязательные псевдонимы по аналогии с обычными входными параметрами. Выходной параметр, как правило переменная, которая вначале имеет значение NULL; 
	ей необходимо присвоить значение во время выполнения функции. Последнее значение выходного параметра - то, что возвращается. 
	Например, предыдущую функцию можно переписать так:
	
	CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
	BEGIN 
		tax := subtotal * 0.06;
	END;
	$$ LANGUAGE plpgsql;
	
	В функции опущено RETURNS real - можно было бы включить, но это было бы избыточным. 
	
	Чтобы вызвать функцию без OUT параметров, можно просто не указывать выходные параметры в вызове функции: 
	
	SELECT sales_tax(100.00);
	
	Выходные параметры наиболее полезные при возврате множества значений. Простейший пример:
	
	CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$  
	BEGIN 
		sum := x + y;
		prod := x * y;
	END;
	$$ LANGUAGE plpgsql;
	
	SELECT * FROM sum_n_product(2, 4); 
	(транспонировал - возвращает что-то похожее на результат запроса)
	sum 6 
	prod 8
	
	Создается анонимный тип RECORD с результатами функции. Если задана конструкция RETURNS, то она должна RETURNS record.
	
	Это также работает с процедурами, например: 
	CREATE PROCEDURE sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$ 
	BEGIN 
		sum := x + y;
		prod := x * y;
	END;
	$$ LANGUAGE plpgsql;
	
	При вызове процедуры должны быть указаны все параметры. Для выходных параметров можно указать null, при вызове процедуры из обычного SQL: 
	
	CALL sum_n_product(2, 4, NULL, NULL);
	sum 6 
	prod 8
	
	Тем не менее, при вызове процедуры из PL/pgSQL необходимо записать значение для каждого выходного параметра - переменная получит результат вызова.
	
	Другой способ объявления функции PL/pgSQL с использованием RETURNS TABLE, например:
	
	CREATE FUNCTION extended_sales(p_itemno int)
	RETURNS TABLE(quantity int, total numeric) AS $$ 
	BEGIN 
		RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s 
		WHERE s.itemno = p_itemno;
	END;
	$$ LANGUAGE plpgsql;
	
	Это эквивалентно объявлению одного или более OUT параметров и указанию RETURNS SETOF sometype.
	
	Когда возвращаемый тип функции объявлен как полиморфический тип, создается специальный параметр $0. Его тип дпнных - действительный возвращаемый тип функции, высчитывается из фактических входных типов данных. Это позволяет функции обращаться к действительному возвращаемому типу, он инициализирован в null и может быть изменен функцией, и может использоваться для хранения возвращаемого значения, несмотря на то, что это не обязательно. $0 можно задать псевдоним, например, так:
	
	CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement) RETURNS anyelement AS $$ 
	DECLARE 
		result ALIAS FOR $0;
	BEGIN 
		result := v1 + v2 + v3;
		RETURN result;
	END;
	$$ LANGUAGE plpgsql;
	
	Тот же эффект можно получить через объявление одного или более выходных параметров как полиморфические типы. В таком случае, специальный параметр $0 не используется, выходные параметры сами по себе служат той же самой цели. Например: 
	
	CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement, OUT sum anyelement) AS $$ 
	BEGIN 
		sum := v1 + v2 + v3;
	END;
	$$ LANGUAGE plpgsql;
	
	На практике более полезно объявлять полиморфную функцию с использованием семейства типов anycompatible, чтобы произошло автоматическое продвижение входных аргументов к общему типу данных, например:
	
	CREATE FUNCTION add_three_values(v1 anycompatible, v2 anycompatible, v3 anycompatible) RETURNS anycompatible AS $$
	BEGIN 
		RETURN v1 + v2 + v3;
	END;
	$$ LANGUAGE plpgsql;
	
	Тогда SELECT add_three_values(1, 2, 4.7); будет работать, автоматически преобразовывая integer в numeric. Функции, использующие anyelement потребуют ручного преобразования трех входных параметров в один и тот же тип.
	
----- Псевдоним -----

newname ALIAS FOR oldname;

Синтаксис ALIAS более обширный, чем было рассмотрено ранее: можно объявить псевдоним для каждой переменной, не только для параметров функций. Главное практическое использование - назначать разные имена для переменных с предопределенными именами, например NEW или OLD в функции триггера. 

Пример: 
	DECLARE 
		prior ALIAS FOR old;
		updated ALIAS FOR new;
		
Так как ALIAS дает два разных способа назвать тот же самый объект, неограниченное использование может приводить к путанице. Лучше использовать только для того, чтобы переписывать предопределенные имена. 

----- Копирование типов -----

variable%TYPE 

%TYPE дает тип данных переменной или колонки таблицы. Можно использовать для объявления переменных, которые будут хранить значения бд. Например, если есть колонка, называющаяся user_id в таблице users. Чтобы объявить переменную того же типа данных, что и users.user_id нужно сделать так: 

user_id users.user_id %TYPE;

При исползовании %TYPE не нужно знать тип данных структуры, на которую ссылаешься, и самое важное, при изменении типа данных у того, на что ссылаешься, может не потребоваться изменять определение функции. 

%TYPE особенно цен в полиморфных функциях, так как типаы данных, требуемые для внутренних переменных могут меняться от вызова к вызову. Подходящие переменные могут быть созданы через применение %TYPE к аргументам функции или итоговым плейсхолдерам. 


----- Типы строк ----- 

name table_name%ROWTYPE;
name composite_type_name;

Переменная сложного типа называется переменной строки, или переменной строчного типа. Такая переменная может содержать целую строку результата запроса SELECT или FOR, до того периода пока множество колонок запроса совпадает с объявленным типом переменной. К отдельным полям можно обращаться через точечную нотацию, например rowvar.field. 

Переменная строки может бьыть объявлена так, чтобы иметь тот же самы тип, что и строки существующей таблицы или представления, путем использования нотации table_name%ROWTYPE; или может быть объявлена через указание названия сложного типа. 

Так как каждая таблица имеет ассоциированный сложный тип с таким же именем, в Postgres обычно не важно пишется ли %ROWTYPE или нет. Но нотация с %ROWTYPE более компактная.

Параметры функции могут бать сложными типами (целые строки таблицы). В таком случае, соответствующий идентификатор $n будет строковой переменной, и к отдельным полям можно обращаться через нее, например, $1.user_id. 

Ниже приведен пример использования сложных типов, table1 и table2 - существующие таблицы, которые имеют указанные ниже поля: 

CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$ 
DECLARE 
	t2_row table2%ROWTYPE;
BEGIN 
	SELECT * INTO t2_row FROM table2 WHERE ...;
	RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;

----- Типы данных RECORD ----

name RECORD;

Переменные RECORD похожи на переменные строкового типа, но у них нет предопределенной структуры. Они принимают действительную структуру строки, когда происходит присваивание во время команды SELECT или FOR. Подструктура переменной RECORD может изменяться каждый раз при присваивании, следовательньно, до первого присвоения у переменной RECORD нет подструктуры и любая попытка доступа к полю - выдаст ошибку выполнения.

Следует обратить внимание, что RECORD - не настоящий тип данных, а всего лишь плейсхолдер. Необходимо понимать, что когда функция объявлена с возвращаемым типом record, это не тот же самый концепт, что и переменная record, даже несмотря на то, что такая функция может использовать переменную RECORD в которой будет храниться результат. В обоих случая действительная структура строки не известна, когда пишется функция, но для функции возвращающей record действительная структура определяется когда происходит разбор запроса, а переменная record может изменять свою структуру строки на лету. 

----- Сопоставимость (collation) переменных ----- 

Когда у функции есть один или более параметров с сопоставимыми типами данных, сопоставимость определяется для каждого вызова функции в зависимости от сопоставимости, присвоенной действительным аргументам. Если сопоставимость успешно идентифицирована (т.е отсутствуют конфликты между неявной сопоставимостью среди аргументов), тогда для всех сопоставимых параметров считается что сопоставимость задана неявно. Это также влияет на поведение чувствительных к сопоставлению операторов внутри функции. Например: 

CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$ 
BEGIN 
	RETURN a < b;
END; 
$$ LANGUAGE plpgsql;

SELECT less_than(text_field_1, text_field_2) FROM table1;
Здесь используется общее сопоставление text_field_1 и text_field_2 для сравнения.

SELECT less_than(text_field_1, text_field_2 COLLATE "C") FROM table1;
Здесь используется сопоставление C.

Более того, итоговое сопоставление предполагается как сопоставление любой из локальных переменных имеющих сопоставимость в типе данных. Функция работала также если бы была написана так: 

CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$ 
DECLARE 
	local_a text := a;
	local_b text := b;
BEGIN 
	RETURN local_a < local_b;
END;
$$ LANGUAGE plpgsql;

Если нет параметров с типами данных у которых есть сопоставимости, или нет общей сопоставимости, которую можно определить для них, тогда параметры и локальные переменные используют сопоставимость по умолчанию для их типа данных (которая, как правило сопоставимость бд по умолчанию, но может различаться для переменных доменного типа данных). 

Локальная переменная или сопоставимый тип данных может иметь отличающуюся сопоставимость если включать опцию COLLATE в объявлении: 

DECLARE 
	local_a text COLLATE "en_US";
	
Такая опция переопределяет сопоставимость, которая будет присвоена переменной согласно правилам сверху. 

Также, можно указать явно COLLATE внутри функции, если требуется насильно использовать определенную сопоставимость у определенной операции. Например: 

CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$
BEGIN
	RETURN a < b COLLATE "C";
END;
$$ LANGUAGE plpgsql;

Это переопределяет сопоставимость ассоциированную с колонками таблиц, параметрами или локальными переменными, использующимися в выражении, также как и в обычной SQL команде.
	