Часто удобно группировать пользователей вместе для облегчения управления привилегиями: таким образом, привилегии можно выдавать или забирать целой группе. В Postgres это делается при помощи создании роли, представляющей собой группу, а затем задания членства в групповой роли индивидуальным ролям пользователей. 

Для настройки групповой роли следует её вначале создать:
CREATE ROLE name;

Обычно групповая роль не имеет атрибут LOGIN, но можно делать как хочешь. 

Когда групповая роль существует, можно добавлять или удалять членов через команды GRANT и REVOKE: 

GRANT group_role TO role11, ... ;
REVOKE group_role FROM role1, ...;

Можно задать членство для других групповых ролей (нет разницы между групповыми ролями и негрупповыми ролями). БД не позволит создать круговое членство (всегда иерархия). Также запрещено давать членство роли PUBLIC. 

Члены групповой роли могут использовать привилегии роли двумя способами. 
Первый способ: каждый член группы может явно выполнить SET ROLE чтобы временно стать групповой ролью. В таком состоянии сессия БД имеет доступ к привилегиям групповой роли вместо привилегий оригинальной роли-пользователя, и любые созданные объекты БД имеют в качестве владельца групповую роль. 
Второй способ: роли-члены могут иметь атрибут INHERIT автоматически использующий привилегии ролей, членами которых они являются, включающий все привилегии наследуемые этими ролями. 

Если мы сделаем так: 

	CREATE ROLE joe LOGIN INHERIT;
	CREATE ROLE admin NOINHERIT;
	CREATE ROLE wheel NOINHERIT;
	GRANT admin TO joe;
	GRANT wheel TO admin;
	
	wheel -> admin -> joe 
	
	После подключения под ролью joe - сессия БД будет использовать как привилегии, выданные напрямую joe, так и привилегии, выданные admin, тк joe наследует привилегии admin. При этом привилегии, выданные wheel не доступны, так как несмотря на то, что joe не является прямым членом wheel, admin не наследует привилегии wheel. После: 
		
	SET ROLE admin;
	
	сессия будет использовать только те привилегии, что назначены admin, но не назначены joe.
	
	После: 
	
	SET ROLE wheel;
	
	сессия будет использовать только те привилегии, что назначены wheel, и не те, что назначены joe или admin. Оригинальное состояние может быть восстановлено при помощи любой из этих команд:
	SET ROLE joe;
	SET ROLE NONE;
	RESET ROLE;
	
Команда SET ROLE всегда позволяет выбрать любую из тех ролей, у которой оригинальная роль с логином является прямым или непрямым членом. 

В стандарте SQL есть четкое различие между пользователями и ролями, и пользователи не наследуют привилегии автоматически в отличие от ролей. Такое же поведение можно получить в Postgres присваивая SQL-ролям атрибут INHERIT, а SQL-пользователям атрибут NOINHERIT. При этом, по умолчанию Postgres выдает всем ролям атрибут INHERIT для обратной совместимости с версиями ранее 8.1, в которых пользователи всегда имели разрешения тех групп, членами которых они были. 

Атрибуты роли LOGIN, SUPERUSER, CREATEDB, CREATEROLE можно рассматривать как специальные привилегии, которые никогда не наследуются как обычные привилегии на объектах БД. Необходимо выполнять команду SET ROLE в определенную роль, для того, чтобы использовать эти специальные привилегии. 

Например, в рассмотренном выше примере, предположим, что мы выдали CREATEDB и CREATEROLE роли admin. Тогда сессия, подключающаяся под ролью joe сможет воспользоваться этими привилегиями при выполнении команды SET ROLE admin. 

Для уничтожения групповой роли следует выполнить DROP ROLE: 
DROP ROLE name;

Все членства групповой роли автоматически отозвутся в результате (но более никакого влияния на роли-члены не будет). 

	
	